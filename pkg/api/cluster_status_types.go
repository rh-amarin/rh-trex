/*
HyperFleet API

HyperFleet API provides simple CRUD operations for managing cluster resources and their status history.  **Architecture**: Simple CRUD only, no business logic, no event creation. Sentinel operator handles all orchestration logic. Adapters handle the specifics of managing spec

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"time"
)

// checks if the ClusterStatus type satisfies the MappedNullable interface at compile time

// ClusterStatus Cluster status aggregation from all adapters.  This object is computed by the service and CANNOT be modified directly. It is aggregated from adapter status updates posted to
type ClusterStatus struct {
	Meta
	Cluster   *Cluster
	ClusterID string
	// Current cluster phase (native database column). Updated when adapters report status. Note: status.phase provides aggregated view from all adapter conditions.
	Phase string
	// When cluster last transitioned (updated by adapters, used by Sentinel for backoff) Updated when adapters report status if the phase changes
	LastTransitionTime time.Time
	// Last generation processed by adapters Updated when adapters report status. This will be the lowest value of each adapter's observed_generation values The phase value is based on this generation
	ObservedGeneration int32
	// Time of the last complete report from adapters Updated when adapters report status. Oldest
	UpdatedAt time.Time
	Adapters  []ConditionAvailable
}

type _ClusterStatus ClusterStatus

// NewClusterStatus instantiates a new ClusterStatus object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewClusterStatus(phase string, lastTransitionTime time.Time, observedGeneration int32, updatedAt time.Time, adapters []ConditionAvailable) *ClusterStatus {
	this := ClusterStatus{}
	this.Phase = phase
	this.LastTransitionTime = lastTransitionTime
	this.ObservedGeneration = observedGeneration
	this.UpdatedAt = updatedAt
	this.Adapters = adapters
	return &this
}

// NewClusterStatusWithDefaults instantiates a new ClusterStatus object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewClusterStatusWithDefaults() *ClusterStatus {
	this := ClusterStatus{}
	return &this
}

// GetPhase returns the Phase field value
func (o *ClusterStatus) GetPhase() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Phase
}

// GetPhaseOk returns a tuple with the Phase field value
// and a boolean to check if the value has been set.
func (o *ClusterStatus) GetPhaseOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Phase, true
}

// SetPhase sets field value
func (o *ClusterStatus) SetPhase(v string) {
	o.Phase = v
}

// GetLastTransitionTime returns the LastTransitionTime field value
func (o *ClusterStatus) GetLastTransitionTime() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.LastTransitionTime
}

// GetLastTransitionTimeOk returns a tuple with the LastTransitionTime field value
// and a boolean to check if the value has been set.
func (o *ClusterStatus) GetLastTransitionTimeOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.LastTransitionTime, true
}

// SetLastTransitionTime sets field value
func (o *ClusterStatus) SetLastTransitionTime(v time.Time) {
	o.LastTransitionTime = v
}

// GetObservedGeneration returns the ObservedGeneration field value
func (o *ClusterStatus) GetObservedGeneration() int32 {
	if o == nil {
		var ret int32
		return ret
	}

	return o.ObservedGeneration
}

// GetObservedGenerationOk returns a tuple with the ObservedGeneration field value
// and a boolean to check if the value has been set.
func (o *ClusterStatus) GetObservedGenerationOk() (*int32, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ObservedGeneration, true
}

// SetObservedGeneration sets field value
func (o *ClusterStatus) SetObservedGeneration(v int32) {
	o.ObservedGeneration = v
}

// GetUpdatedAt returns the UpdatedAt field value
func (o *ClusterStatus) GetUpdatedAt() time.Time {
	if o == nil {
		var ret time.Time
		return ret
	}

	return o.UpdatedAt
}

// GetUpdatedAtOk returns a tuple with the UpdatedAt field value
// and a boolean to check if the value has been set.
func (o *ClusterStatus) GetUpdatedAtOk() (*time.Time, bool) {
	if o == nil {
		return nil, false
	}
	return &o.UpdatedAt, true
}

// SetUpdatedAt sets field value
func (o *ClusterStatus) SetUpdatedAt(v time.Time) {
	o.UpdatedAt = v
}

// GetAdapters returns the Adapters field value
func (o *ClusterStatus) GetAdapters() []ConditionAvailable {
	if o == nil {
		var ret []ConditionAvailable
		return ret
	}

	return o.Adapters
}

// GetAdaptersOk returns a tuple with the Adapters field value
// and a boolean to check if the value has been set.
func (o *ClusterStatus) GetAdaptersOk() ([]ConditionAvailable, bool) {
	if o == nil {
		return nil, false
	}
	return o.Adapters, true
}

// SetAdapters sets field value
func (o *ClusterStatus) SetAdapters(v []ConditionAvailable) {
	o.Adapters = v
}

func (o ClusterStatus) MarshalJSON() ([]byte, error) {
	toSerialize, err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o ClusterStatus) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["phase"] = o.Phase
	toSerialize["last_transition_time"] = o.LastTransitionTime
	toSerialize["observed_generation"] = o.ObservedGeneration
	toSerialize["updated_at"] = o.UpdatedAt
	toSerialize["adapters"] = o.Adapters
	return toSerialize, nil
}

func (o *ClusterStatus) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"phase",
		"last_transition_time",
		"observed_generation",
		"updated_at",
		"adapters",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)
	if err != nil {
		return err
	}

	for _, requiredProperty := range requiredProperties {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varClusterStatus := _ClusterStatus{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varClusterStatus)
	if err != nil {
		return err
	}

	*o = ClusterStatus(varClusterStatus)

	return err
}

type NullableClusterStatus struct {
	value *ClusterStatus
	isSet bool
}

func (v NullableClusterStatus) Get() *ClusterStatus {
	return v.value
}

func (v *NullableClusterStatus) Set(val *ClusterStatus) {
	v.value = val
	v.isSet = true
}

func (v NullableClusterStatus) IsSet() bool {
	return v.isSet
}

func (v *NullableClusterStatus) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableClusterStatus(val *ClusterStatus) *NullableClusterStatus {
	return &NullableClusterStatus{value: val, isSet: true}
}

func (v NullableClusterStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableClusterStatus) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

// clusterStatusStorage is an intermediate structure for database storage
// that matches the JSON output from MarshalJSON/ToMap
type clusterStatusStorage struct {
	Phase              string                 `json:"phase"`
	LastTransitionTime time.Time              `json:"last_transition_time"`
	ObservedGeneration int32                  `json:"observed_generation"`
	UpdatedAt          time.Time              `json:"updated_at"`
	Adapters           []ConditionAvailable   `json:"adapters"`
}

// Value implements the driver.Valuer interface for GORM to serialize ClusterStatus to JSONB
func (o ClusterStatus) Value() (driver.Value, error) {
	// Convert to storage format using the same structure as ToMap()
	storage := clusterStatusStorage{
		Phase:              o.Phase,
		LastTransitionTime: o.LastTransitionTime,
		ObservedGeneration: o.ObservedGeneration,
		UpdatedAt:          o.UpdatedAt,
		Adapters:           o.Adapters,
	}
	return json.Marshal(storage)
}

// Scan implements the sql.Scanner interface for GORM to deserialize JSONB to ClusterStatus
func (o *ClusterStatus) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	var bytes []byte
	switch v := value.(type) {
	case []byte:
		bytes = v
	case string:
		bytes = []byte(v)
	default:
		return fmt.Errorf("failed to scan ClusterStatus: unsupported type %T", value)
	}

	// Unmarshal into storage format first
	var storage clusterStatusStorage
	if err := json.Unmarshal(bytes, &storage); err != nil {
		return err
	}

	// Convert from storage format to ClusterStatus
	o.Phase = storage.Phase
	o.LastTransitionTime = storage.LastTransitionTime
	o.ObservedGeneration = storage.ObservedGeneration
	o.UpdatedAt = storage.UpdatedAt
	o.Adapters = storage.Adapters

	return nil
}
